\subsection{Introduction}
In order to spoof the onboard GPS, the CAN-bus was chosen as input to AQ. 
The CAN-bus is already implemented and widely used on a ViaCopter drone to communicate between AQ and hardware like ESCs, PDB etc. Much time was spend reading through the source code and trying to figure out how the protocol works.
The developers behind AQ says, that the code is the documentation and thereby have not written any real documentation. \\
Figuring out how it works was done using debugging utilities such as breakpoints and looking at the content of the different memory locations in CrossWorks.
To further investigate the protocol a PEAK-CAN adapter were connected to a Ladybird drone and several python scripts were developed to send and receive messages from AQ. \\
The author did not go into details about messages used between AQ $\leftrightarrow$ ESC's and AQ $\leftrightarrow$ OSD.\\


\subsection{CAN Protocol description}
A Peak-CAN adapter were used throughout the project. It supports High-speed ISO 11898-2\footnote{\url{http://www.peak-system.com/PCAN-USB.199.0.html?&L=1}} which is a standard that states the properties of physical layer. 
Its max speed is 1 mbit which is the speed AQ uses to communicate on the CAN-bus. 
AQ uses CAN 2.0B which has 29 identifier bits.
AQ is not using an existing protocol on top of ISO 11898-2. The developers created their own to suit their needs.\\

\subsubsection{Identifier bits}
A Generic look at a AQ CAN messages can be seen in table \ref{tab:can_identifier_bits}.
The normal function of the identifier bits is the priority of the messages.
A CAN controller can then be setup to only allow certain messages to be processed depending on their identifier bits.
The identification bits has been split up in AQ to contain information about the sender, receiver etc. Which is not normally saved information in a CAN message.
\input{modules/Can-description.tex}

\subsubsection{Logic Communication Channel}
LCC is the priority of the message. 
To understand how LCC works, one needs to look into CAN arbitration.
As stated in ISO-11898-2, a 0 is the dominant bit and a 1 is the recessive bit.
The example in figure \ref{tab:can_arbitration} shows two nodes each transmitting a packet.
The arbitration only happens during the transmission of the identifier bits.
In the example on bit 8, Node 16 losses the arbitration and stops transmitting.
Node 15 keeps transmitting its packet because it has lower identifier bits and thereby higher priority.
\begin{figure}[H]
    \center
    \includegraphics[width=1\textwidth]{graphics/can_arbitration.eps}
    \caption{Example of CAN arbitration where node 15 has the lowest ID and thereby highest priority}
    \label{tab:can_arbitration}
\end{figure}
\newpage
LLC in a message can take one of the defines in code \ref{code:llc_defines}
\begin{lstlisting}[language = c, caption = LLC defines, label=code:llc_defines]
#define CAN_LCC_EXCEPTION   ((uint32_t)0x0<<30)
#define CAN_LCC_HIGH        ((uint32_t)0x1<<30)
#define CAN_LCC_NORMAL      ((uint32_t)0x2<<30)
#define CAN_LCC_INFO        ((uint32_t)0x3<<30)
\end{lstlisting}

\begin{table}[H]
\centering
\caption{Table showing the 4 types of priority in AQ}
\label{my-label}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Name} & \textbf{Value} & \textbf{Priority (lowest first)} \\ \hline
EXCEPTION     & 0000           & 0                 \\ \hline
HIGH          & 0001           & 1                 \\ \hline
NORMAL        & 0010           & 2                 \\ \hline
INFO          & 0011           & 3                 \\ \hline
\end{tabular}
\end{table}

\subsubsection{Target Type}
Target type can either be “node” or “group” depending on if the receiver(s) is one or more nodes. 
\begin{lstlisting}[language = c, caption = Target type defined in AQ, label=code:target_types]
#define CAN_TT_GROUP        ((uint32_t)0x0<<29)
#define CAN_TT_NODE         ((uint32_t)0x1<<29)
\end{lstlisting}
The GROUP is used when AQ sends its reset-msg upon startup.\\
When the authors node send a sensor-measure to AQ it will be of type NODE.
\subsubsection{Function ID}

Function ID describes the function of the CAN message. If it is a PING, ACK, NACK, etc.
It simply states the function of packet so the receiver node knows what to do with the message.
Different types of functions can be seen in code \ref{code:function_defines}
\begin{lstlisting}[language = c, caption = Excerpts from AQ's list of function defines, label=code:function_defines]
#define CAN_FID_RESET_BUS		((uint32_t)0x0<<25)
#define CAN_FID_ACK				((uint32_t)0x1<<25)
#define CAN_FID_REQ_ADDR		((uint32_t)0x7<<25)
#define CAN_FID_GRANT_ADDR	((uint32_t)0x8<<25)
\end{lstlisting}

Table \ref{tab:fid_descriptions} describes the FIDs shown in code \ref{code:function_defines}.
\begin{table}[H]
\centering
\caption{Descriptions of the FIDs mentioned in code \ref{code:function_defines}}
\label{tab:fid_descriptions}
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}|l|l|@{}}
\toprule
\textbf{FID}          & \textbf{Description}                                                               \\ \midrule
CAN\_FID\_RESET\_BUS  & Message sent by AQ when powered up                                                 \\ \midrule
CAN\_FID\_ACK         & Message sent to AQ when acknowledging a received message                           \\ \midrule
CAN\_FID\_REQ\_ADDR   & Messaged used when a node on the bus tries to register itself as a node on the bus \\ \midrule
CAN\_FID\_GRANT\_ADDR & Messaged sent by AQ when it registers a node as a node on the bus.                 \\ \bottomrule
\end{tabular}
}
\end{table}

Table \ref{tab:fid_descriptions} shows a description of the 4 FIDs used when a node is registered. 

\subsubsection{Data Object Code}
Comming.. Kind of parameter to FID
\Mathias{eksempel på hvordan de bliver brugt i koden - vise function id i switch/case}
\Mathias{Dscripe how the node is created on the BUS}

\subsubsection{Source/Target/Network ID}
When referred to source/target ID but without respect to either sender or receiver but just a CAN-node, then it is referred to as NetworkId. When a node registers itself in AQ, it gets assigned a NetworkId.

\subsubsection{Sequence ID}
The sequence id is incremented on transmission of each message. It is used when eg. 
A CAN-node sends a reply to a get-message, it is then including the sequence id of the get-message so AQ knows what it receives a reply for.

\subsubsection{Data bits}
The data bytes does not have a general definition, it depends on the function id. With some FIDs the data field may contain additional parameters.\\ \\
Eg. When FID is CAN\_FID\_REQ\_ADDR, data has the fields shown in table \ref{tab:packet_from_node}
\begin{table}[H]
\centering
\caption{Packet sent from node when registering in AQ}
\label{tab:packet_from_node}
\begin{tabular}{@{}|c|c|c|c|c|c|c|c|@{}}
\toprule
\multicolumn{8}{|c|}{64 bits}                           \\ \midrule
0 & 0 & CanId & CanType & UUID3 & UUID2 & UUID1 & UUID0 \\
\midrule
7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\ \bottomrule
\end{tabular}
\end{table}

\textbf{UUID} is a unique address generated by each node on the bus. In ESC32v2\footnote{\url{https://github.com/bn999/esc32/blob/master/onboard/can.c}} the address is calculated using XXH-hashing algorithm. The algorithm generates a 32 bit hash from a given input value and a salt.
The input to XXH in ESC32v2 is the unique ID that every ARM in the STMF32\footnote{\url{http://www2.st.com/content/ccc/resource/technical/document/reference_manual/59/b9/ba/7f/11/af/43/d5/CD00171190.pdf/files/CD00171190.pdf/jcr:content/translations/en.CD00171190.pdf}}
 family has. Code \ref{code:xxh_canesc32v2} shows how it is implemented in AQ.

\begin{lstlisting}[language = c, caption = Snippet showing UUID generated in ESC32v2, label=code:xxh_canesc32v2]
can.h:20
#define CAN_UUID	0x1FFFF7E8

can.c:753
canData.uuid = XXH32((void *)CAN_UUID, 3*4, 0);
\end{lstlisting}

\textbf{CanType} is the type of the node trying to register. Eq. SENSOR, ESC and SERVO.  \\

\textbf{CanID} is the number of the CanType node trying to register. When an ESC32v2 is trying to register it sends CanId as the ESC number ranging from 1 to the number of ESC's mounted on the drone. The CanID is assign to each ESC manually as part of the configuring.

% redefine the \mess so that \_ works...
\renewcommand{\mess}[4][0]{
  \stepcounter{seqlevel}
  \path
  (#2)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess from) {};
  \addtocounter{seqlevel}{#1}
  \path
  (#4)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess to) {};
  \draw[->,>=angle 60] (mess from) -- (mess to) node[midway, above]
  {#3};
}

\subsection{Registering a node in AQ}

.....
\begin{figure}[H]
    \center
      \begin{adjustbox}{max width=0.5\textwidth}
	\begin{sequencediagram}
	  \newthread{0.4}{pynode}{ROS-node}
	  \newthread{7}{autoquad}{AutoQuad}

	  \mess[1]{autoquad}{CAN\_FID\_RESET\_BUS}{pynode}

	  \begin{call}[3]{autoquad}{Wait(100ms)}{autoquad}
			\postlevel
			\postlevel
			\mess{pynode}{CAN\_FID\_REQ\_ADDR}{autoquad}
			\postlevel
			\mess{autoquad}{CAN\_FID\_GRANT\_ADDR}{pynode}
	  \end{call}
	  \mess{autoquad}{CanTelemeryValue}{pynode}
	  \mess{pynode}{ACKValue*}{autoquad}
	  \postlevel

  	  \mess{autoquad}{CanTelemetryRate}{pynode}
  	  \mess{pynode}{ACKRate}{autoquad}
	\end{sequencediagram}
	\end{adjustbox}
	\label{fig:protocol_req_node}
	\caption{Registering a new node in AQ}
\end{figure}

Test of sending sensor data
\begin{figure}[H]
    \center
    \includegraphics[width=0.8\textwidth]{graphics/test_can_spoof_current.png}
    \caption{Test of python CAN test}
    \label{fig:PCB_block}
\end{figure}